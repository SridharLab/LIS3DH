/*
  LISH3D_core_spi.cpp - Library for interacting with the STMicro LIS3DH
                        MEMS digital output motion sensor, ultra low-power
                        high performance 3-axes “nano” accelerometer.
  Created by Craig Wm. Versek, 2014-12-04
 */
#include <Arduino.h>
#include <SPI.h>
#include "LIS3DH_BiopotADC.h"
 
LIS3DH_CoreSPIClass::LIS3DH_CoreSPIClass(const int slaveSelectLowPin,
                                         const int dataReadyLowPin
                                        ){
  _slaveSelectLowPin = slaveSelectLowPin;
  _dataReadyLowPin   = dataReadyLowPin;
}

void LIS3DH_CoreSPIClass::begin(int startup_delay_ms) {
  //wait for the LIS3DH to be ready - it can take a while to charge caps
  delay(startup_delay_ms); 
  // Configure the Arduino pins
  pinMode(_slaveSelectLowPin, OUTPUT);
  pinMode(_dataReadyLowPin, INPUT);
  digitalWrite(_slaveSelectLowPin, HIGH);  //comm. off
}


int LIS3DH_CoreSPIClass::startConversions(){
  digitalWrite(_slaveSelectLowPin, LOW);
  SPI.transfer(LIS3DH::START);
  delayMicroseconds(1);
  digitalWrite(_slaveSelectLowPin, HIGH);
  delayMicroseconds(2);
  return 0;
}

int LIS3DH_CoreSPIClass::stopConversions(){
  digitalWrite(_slaveSelectLowPin, LOW);
  SPI.transfer(LIS3DH::STOP);
  delayMicroseconds(1);
  digitalWrite(_slaveSelectLowPin, HIGH);
  delayMicroseconds(2);
  return 0;
}

int LIS3DH_CoreSPIClass::readDataRaw(byte *data_array){
  //while (digitalRead(_dataReadyLowPin)){}
  //data_array must be at least 27 bytes
  digitalWrite(_slaveSelectLowPin, LOW);
  SPI.transfer(LIS3DH::RDATA);
  for(int i = 0; i < RDATA_NUM_BYTES; i++){
    data_array[i] = SPI.transfer(0);
  }
  delayMicroseconds(1);
  digitalWrite(_slaveSelectLowPin, HIGH);
  //delay(10);
  return 0;
}


void LIS3DH_CoreSPIClass::attach_dataReadyLow_interrupt(void (*function)(void)){
  attachInterrupt(_dataReadyLowPin, function, FALLING);
}

void LIS3DH_CoreSPIClass::detach_dataReadyLow_interrupt(){
  detachInterrupt(_dataReadyLowPin);
}

byte LIS3DH_CoreSPIClass::_readRegister(int addr) {
  byte opcode1, opcode2, data;
  opcode1 = LIS3DH::RREG | (addr & 0b00011111);
  opcode2 = 0b00000000;// | (n    & 0b00011111); //FIXME we only ever need to read 1 byte at a time, right?
  digitalWrite(_slaveSelectLowPin, LOW);  //set chip as listener
  SPI.transfer(opcode1);                  //send command
  delayMicroseconds(5);
  SPI.transfer(opcode2);
  delayMicroseconds(5);
  data = SPI.transfer(0);                 //read back response (sending null byte)
  delayMicroseconds(1);
  digitalWrite(_slaveSelectLowPin, HIGH); //release chip select
  return data;
}


int LIS3DH_CoreSPIClass::_writeRegister(int addr, byte value) {
  if(addr > 0 && addr <= ADDR_MAX){
    byte opcode1, opcode2;
    opcode1 = LIS3DH::WREG | (addr &  0b00011111);
    opcode2 = 0b00000000;// | (n    & 0b00011111); //FIXME we only ever need to read 1 byte at a time, right?
    digitalWrite(_slaveSelectLowPin, LOW);
    SPI.transfer(opcode1);
    delayMicroseconds(5);
    SPI.transfer(opcode2);  // number of registers to be read/written – 1
    SPI.transfer(value);    // send the data
    delayMicroseconds(1);
    digitalWrite(_slaveSelectLowPin, HIGH);
    return 0;
  }
  else{ return -1; }          //error, out of range
}

//float LIS3DH_CoreSPIClass::readSingle(int channel){
//  int data;
//  float voltage;
//  data = readRawSingle(channel);
//  voltage = (data*_refVoltage)/(RES12BIT - 1.0);
//  return voltage;
//}

//int LIS3DH_CoreSPIClass::readRawSingle(int channel){
//  word cmd;                       //0,0,0,0,0,1,sgl=0,d2    d1,d0,x,x,x,x,x,x
//  int data;                       //?,?,?,0,b11,b10,b9,b8   b7,b6,b5,b4,b3,b2,b1,b0
//  //configure command
//  cmd  =  0b110 << 8;             //start bit, single ended
//  cmd |= (channel & 0b111) << 6;  //d2,d1,d0 -- sampling channel
// // Serial.println(cmd);
//  digitalWrite(_slaveSelectLowPin, LOW);  //set chip as listener
//  SPI.transfer(highByte(cmd));            //send first command byte, ignore first returned byte
//  data  = SPI.transfer(lowByte(cmd));     //send second command byte, get data high byte
//  data  = (data & 0b1111) << 8;           //b11,b10,b9,b8
//  data |= SPI.transfer(0);                //send null byte, get data low byte b7-b0
//  digitalWrite(_slaveSelectLowPin, HIGH); //release chip select
//  return data;
//}
